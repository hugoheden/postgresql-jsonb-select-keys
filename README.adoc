= jsonb_select_keys - a PostgreSQL function

A postgresql function for "deep-selecting" a subset of a json document (well jsonb).
(Is "projection" a better term?)

Tested with postgres 12

Warning: Never used or tested in production!

The code:

[source,sql]
----
include::jsonb_select_keys.sql[]
----

Usage example:

[source,sql]
----
select
    jsonb_select_keys(
            '{"a": "x", "b": {"c": "y", "d": "z"}}', -- doc

            '{"b": {"c": 1}}' -- selection

        );
-- result: {"b": {"c": "y"}}
----

== A few examples

include::demos/examples.adoc[]

== Some notes

* By "doc" we mean the jsonb document that we want to process.
* By "selection" we mean the json snippet that specifies the fields in the doc that we are interested in
* The selection must be a json object (it can't be a scalar or a list)
* The selection object can only contain values that are objects or the scalar number "1".
(The same rule applies recursively to the sub-objects in the selection)
* There is no way to say "just select the whole document".
** We could add that, by allowing the caller to just pass the number "1" as a selection, and let that mean "select the whole document"
* This whole concept is similar to (but simpler variant of) what MongoDB calls a "projection"
* Use case: save network traffic (and application CPU?) by only pulling subsets of json that are actually needed by the application.
Might be useful when having legacy DB with big legacy json-documents, and there is a slow query that really only needs a small sub-set, a deep sub-selection, of the stored json-documents.
* The cost is significant CPU usage (queries get slower) on the database server
* It is somewhat quirky that the resulting document can contain lots of empty objects or lists (MongoDB behaves similarly)
** We could fix that and make sure to filter out empty objects and lists (but I am not sure this could be done without a performance penalty)
* In MongoDB "sub-projection" (a sub-object of the selection) must not be empty, i.e no '{}'.
If such an object is found, an error is emitted.
We do it differently (to make the function simpler and maybe faster) - an empty object in the selection means "no fields are of interest".
We thus don't have to do such a check or maintain logic for raising an error.
* In MongoDB, an object in the selection does NOT match a scalar in the document.
We do it differently (but only because it is easier)
* The root level of the document in mongo is always an object (I think).
But we we want to support root level lists too
* Somewhat related:
** https://dba.stackexchange.com/questions/290005/how-to-select-sub-object-with-given-keys-from-jsonb
** https://dba.stackexchange.com/questions/265731/how-to-select-subset-json-with-postgresql

== A bunch of small examples

include::demos/examples_many_small.adoc[]
